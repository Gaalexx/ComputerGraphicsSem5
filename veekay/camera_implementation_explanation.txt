================================================================================
ОБЪЯСНЕНИЕ РЕАЛИЗАЦИИ ВРАЩЕНИЯ КАМЕРЫ И LOOK-AT МАТРИЦЫ
================================================================================

ТЕОРЕТИЧЕСКАЯ ОСНОВА:
--------------------
Реализация основана на следующих концепциях компьютерной графики:

1. Look-At матрица (View Matrix) - преобразует координаты из мирового 
   пространства в пространство камеры
   
2. Euler углы (Yaw/Pitch/Roll) - представление ориентации через углы поворота:
   - Yaw (рыскание) - поворот вокруг оси Y (влево-вправо)
   - Pitch (тангаж) - поворот вокруг оси X (вверх-вниз)
   - Roll (крен) - поворот вокруг оси Z (не используется)

3. Ортонормированный базис камеры - три взаимно перпендикулярных единичных 
   вектора (right, up, front), определяющих ориентацию камеры

================================================================================
ИЗМЕНЕНИЕ 1: МЕТОД Camera::view()
================================================================================

БЫЛО:
-----
veekay::mat4 Camera::view() const {
    // TODO: Rotation
    auto t = veekay::mat4::translation(-position);
    return t;
}

СТАЛО:
------
veekay::mat4 Camera::view() const {
    // Строка 1-2: Конвертация углов Эйлера в радианы
    float yaw_rad = toRadians(rotation.y);
    float pitch_rad = toRadians(-rotation.x);
    
    // Строка 4-8: Вычисление вектора направления взгляда из углов Эйлера
    veekay::vec3 front = {
        cosf(pitch_rad) * sinf(yaw_rad),
        sinf(pitch_rad),
        cosf(pitch_rad) * cosf(yaw_rad)
    };
    front = veekay::vec3::normalized(front);
    
    // Строка 10-12: Построение ортонормированного базиса камеры
    veekay::vec3 world_up = {0.0f, 1.0f, 0.0f};
    veekay::vec3 right = veekay::vec3::normalized(veekay::vec3::cross(front, world_up));
    veekay::vec3 up = veekay::vec3::cross(right, front);
    
    // Строка 14: Вычисление целевой точки взгляда
    veekay::vec3 target = position + front;
    
    // Строка 16-18: Определение осей координат камеры
    veekay::vec3 z = veekay::vec3::normalized(position - target);
    veekay::vec3 x = right;
    veekay::vec3 y = up;
    
    // Строка 20-26: Построение Look-At матрицы
    veekay::mat4 result = veekay::mat4::identity();
    result[0][0] = x.x; result[1][0] = x.y; result[2][0] = x.z;
    result[0][1] = y.x; result[1][1] = y.y; result[2][1] = y.z;
    result[0][2] = z.x; result[1][2] = z.y; result[2][2] = z.z;
    result[3][0] = -veekay::vec3::dot(x, position);
    result[3][1] = -veekay::vec3::dot(y, position);
    result[3][2] = -veekay::vec3::dot(z, position);
    
    return result;
}

ПОСТРОЧНОЕ ОБЪЯСНЕНИЕ:
----------------------

Строка 1-2: Конвертация углов в радианы
    float yaw_rad = toRadians(rotation.y);
    float pitch_rad = toRadians(-rotation.x);
    
    - rotation.y содержит угол yaw в градусах
    - rotation.x содержит угол pitch в градусах
    - Инверсия pitch (-rotation.x) нужна для правильной ориентации в системе 
      координат с Y вверх
    - toRadians() конвертирует градусы в радианы для тригонометрических функций

Строка 4-8: Вычисление направления взгляда (front vector)
    veekay::vec3 front = {
        cosf(pitch_rad) * sinf(yaw_rad),
        sinf(pitch_rad),
        cosf(pitch_rad) * cosf(yaw_rad)
    };
    front = veekay::vec3::normalized(front);
    
    ФОРМУЛЫ ОСНОВАНЫ НА СФЕРИЧЕСКИХ КООРДИНАТАХ:
    - X = cos(pitch) * sin(yaw)  - горизонтальная компонента направления
    - Y = sin(pitch)              - вертикальная компонента направления
    - Z = cos(pitch) * cos(yaw)  - глубинная компонента направления
    
    Эти формулы преобразуют углы Эйлера в единичный вектор направления.
    Нормализация гарантирует, что длина вектора равна 1.

Строка 10: Определение мирового вектора "вверх"
    veekay::vec3 world_up = {0.0f, 1.0f, 0.0f};
    
    - Определяет глобальное направление "вверх" в мировых координатах
    - Используется как опорный вектор для построения базиса камеры

Строка 11: Вычисление вектора "вправо" (right vector)
    veekay::vec3 right = veekay::vec3::normalized(veekay::vec3::cross(front, world_up));
    
    - Векторное произведение front × world_up дает вектор, перпендикулярный обоим
    - Этот вектор указывает направо относительно камеры
    - Нормализация делает его единичным

Строка 12: Вычисление вектора "вверх" камеры (up vector)
    veekay::vec3 up = veekay::vec3::cross(right, front);
    
    - Векторное произведение right × front дает вектор "вверх" камеры
    - Этот вектор перпендикулярен и right, и front
    - Нормализация не нужна, т.к. оба входных вектора уже единичные и перпендикулярные

Строка 14: Вычисление целевой точки
    veekay::vec3 target = position + front;
    
    - Точка, на которую смотрит камера
    - Находится на расстоянии 1 единицы от позиции камеры в направлении front

Строка 16-18: Переименование осей для Look-At матрицы
    veekay::vec3 z = veekay::vec3::normalized(position - target);
    veekay::vec3 x = right;
    veekay::vec3 y = up;
    
    - z указывает от target к position (противоположно направлению взгляда)
    - x указывает вправо
    - y указывает вверх
    - Эти три вектора образуют правую систему координат камеры

Строка 20-26: Построение Look-At матрицы
    veekay::mat4 result = veekay::mat4::identity();
    result[0][0] = x.x; result[1][0] = x.y; result[2][0] = x.z;
    result[0][1] = y.x; result[1][1] = y.y; result[2][1] = y.z;
    result[0][2] = z.x; result[1][2] = z.y; result[2][2] = z.z;
    result[3][0] = -veekay::vec3::dot(x, position);
    result[3][1] = -veekay::vec3::dot(y, position);
    result[3][2] = -veekay::vec3::dot(z, position);
    
    СТРУКТУРА МАТРИЦЫ:
    | x.x  y.x  z.x  -dot(x,pos) |
    | x.y  y.y  z.y  -dot(y,pos) |
    | x.z  y.z  z.z  -dot(z,pos) |
    |  0    0    0        1      |
    
    - Верхний левый блок 3×3: матрица поворота (базисные векторы камеры)
    - Правый столбец: смещение (проекция позиции на оси камеры с инверсией)
    - Эта матрица преобразует мировые координаты в координаты камеры

================================================================================
ИЗМЕНЕНИЕ 2: ФУНКЦИЯ update() - УПРАВЛЕНИЕ КАМЕРОЙ
================================================================================

БЫЛО:
-----
if (mouse::isButtonDown(mouse::Button::left)) {
    auto move_delta = mouse::cursorDelta();
    // TODO: Use mouse_delta to update camera rotation
    
    auto view = camera.view();
    // TODO: Calculate right, up and front from view matrix
    veekay::vec3 right = {1.0f, 0.0f, 0.0f};
    veekay::vec3 up = {0.0f, -1.0f, 0.0f};
    veekay::vec3 front = {0.0f, 0.0f, 1.0f};
    
    if (keyboard::isKeyDown(keyboard::Key::w))
        camera.position += front * 0.1f;
    // ... остальные клавиши
}

СТАЛО:
------
if (mouse::isButtonDown(mouse::Button::left)) {
    auto move_delta = mouse::cursorDelta();
    
    camera.rotation.y += move_delta.x * 0.2f;
    camera.rotation.x -= move_delta.y * 0.2f;
    
    if (camera.rotation.x > 89.0f) camera.rotation.x = 89.0f;
    if (camera.rotation.x < -89.0f) camera.rotation.x = -89.0f;
}

float yaw_rad = toRadians(camera.rotation.y);
float pitch_rad = toRadians(-camera.rotation.x);

veekay::vec3 front = {
    cosf(pitch_rad) * sinf(yaw_rad),
    sinf(pitch_rad),
    cosf(pitch_rad) * cosf(yaw_rad)
};
front = veekay::vec3::normalized(front);

veekay::vec3 world_up = {0.0f, 1.0f, 0.0f};
veekay::vec3 right = veekay::vec3::normalized(veekay::vec3::cross(front, world_up));
veekay::vec3 up = veekay::vec3::cross(right, front);

if (keyboard::isKeyDown(keyboard::Key::w))
    camera.position += front * 0.1f;
// ... остальные клавиши

ПОСТРОЧНОЕ ОБЪЯСНЕНИЕ:
----------------------

Блок 1: Обработка движения мыши
    if (mouse::isButtonDown(mouse::Button::left)) {
        auto move_delta = mouse::cursorDelta();
        
        camera.rotation.y += move_delta.x * 0.2f;
        camera.rotation.x -= move_delta.y * 0.2f;
        
        if (camera.rotation.x > 89.0f) camera.rotation.x = 89.0f;
        if (camera.rotation.x < -89.0f) camera.rotation.x = -89.0f;
    }
    
    - Проверяет, зажата ли левая кнопка мыши
    - cursorDelta() возвращает смещение курсора с предыдущего кадра
    - move_delta.x (горизонтальное движение) изменяет yaw (rotation.y)
    - move_delta.y (вертикальное движение) изменяет pitch (rotation.x)
    - Коэффициент 0.2 контролирует чувствительность мыши
    - Ограничение pitch в диапазоне [-89°, 89°] предотвращает gimbal lock
      (переворот камеры при достижении ±90°)

Блок 2: Вычисление векторов направления камеры
    float yaw_rad = toRadians(camera.rotation.y);
    float pitch_rad = toRadians(-camera.rotation.x);
    
    veekay::vec3 front = {
        cosf(pitch_rad) * sinf(yaw_rad),
        sinf(pitch_rad),
        cosf(pitch_rad) * cosf(yaw_rad)
    };
    front = veekay::vec3::normalized(front);
    
    - Идентично вычислениям в Camera::view()
    - Преобразует текущие углы камеры в вектор направления взгляда
    - Этот вектор используется для перемещения камеры вперед/назад

Блок 3: Построение ортонормированного базиса
    veekay::vec3 world_up = {0.0f, 1.0f, 0.0f};
    veekay::vec3 right = veekay::vec3::normalized(veekay::vec3::cross(front, world_up));
    veekay::vec3 up = veekay::vec3::cross(right, front);
    
    - Вычисляет векторы right и up относительно текущего направления камеры
    - right используется для перемещения влево/вправо (клавиши A/D)
    - up используется для перемещения вверх/вниз (клавиши Q/E)

Блок 4: Обработка клавиш перемещения
    if (keyboard::isKeyDown(keyboard::Key::w))
        camera.position += front * 0.1f;
    if (keyboard::isKeyDown(keyboard::Key::s))
        camera.position -= front * 0.1f;
    if (keyboard::isKeyDown(keyboard::Key::d))
        camera.position += right * 0.1f;
    if (keyboard::isKeyDown(keyboard::Key::a))
        camera.position -= right * 0.1f;
    if (keyboard::isKeyDown(keyboard::Key::e))
        camera.position += up * 0.1f;
    if (keyboard::isKeyDown(keyboard::Key::q))
        camera.position -= up * 0.1f;
    
    - W/S: движение вперед/назад вдоль вектора front
    - A/D: движение влево/вправо вдоль вектора right
    - Q/E: движение вниз/вверх вдоль вектора up
    - Коэффициент 0.1 определяет скорость перемещения
    - Все перемещения относительны текущей ориентации камеры

================================================================================
КЛЮЧЕВЫЕ МАТЕМАТИЧЕСКИЕ КОНЦЕПЦИИ
================================================================================

1. ВЕКТОРНОЕ ПРОИЗВЕДЕНИЕ (Cross Product):
   - a × b = вектор, перпендикулярный и a, и b
   - Используется для построения ортогональных векторов базиса камеры
   - Порядок важен: a × b = -(b × a)

2. СКАЛЯРНОЕ ПРОИЗВЕДЕНИЕ (Dot Product):
   - a · b = |a| * |b| * cos(θ)
   - Для единичных векторов: a · b = проекция a на b
   - Используется для вычисления смещения в Look-At матрице

3. НОРМАЛИЗАЦИЯ:
   - Преобразует вектор в единичный (длина = 1)
   - v_normalized = v / |v|
   - Необходима для корректной работы с направлениями

4. EULER УГЛЫ → НАПРАВЛЕНИЕ:
   - Преобразование из углов в декартовы координаты
   - Основано на сферических координатах
   - Позволяет интуитивно управлять ориентацией

5. LOOK-AT МАТРИЦА:
   - Комбинация поворота и смещения
   - Преобразует мировые координаты в координаты камеры
   - Инверсия трансформации камеры

================================================================================
ИТОГОВАЯ ФУНКЦИОНАЛЬНОСТЬ
================================================================================

✓ Вращение камеры мышью (при зажатой левой кнопке)
✓ Ограничение вертикального угла для предотвращения переворота
✓ Перемещение относительно направления взгляда камеры:
  - W/S: вперед/назад
  - A/D: влево/вправо
  - Q/E: вверх/вниз
✓ Look-At матрица для корректного преобразования координат
✓ Сохранение начального положения камеры и объектов сцены
